"statistic_with_C_sample"),
envir = environment())
# par_test <- function(n){
#   parSapply(cl = cl, seq(n), function(i){boot_function_0(nboot, list_of_samples[[1]])})
#par_test(1000)
# }
#results <- parLapply(cl = cl, list_of_samples, boot_function_0)
results <- parLapply(cl = cl, list_of_samples, boot_function_2)
stopCluster(cl)
end_parallel <- Sys.time()
time_parallel <- end_parallel - start_parallel
time_parallel
stopCluster(cl)
#----------------
# Bootstrap power
#----------------
# Sets: A==1 and B==1
P_A_e = data[A==1&E==1, .N]/data[E==1, .N]
P_A_ne = data[A==1&E==0, .N]/data[E==0, .N]
P_B_e = data[B==1&E==1, .N]/data[E==1, .N]
P_B_ne = data[B==1&E==0, .N]/data[E==0, .N]
P_C_e = data[C==1&E==1, .N]/data[E==1, .N]
P_C_ne = data[C==1&E==0, .N]/data[E==0, .N]
P_A =  data[A==1, .N]/N
P_B = data[B==1, .N]/N
P_C = data[C==1, .N]/N
DT_A <- data[A==1]
DT_B <- data[B==1]
DT_C <- data[C==1]
#---------------------------------------------
# Generation nsam original samples in parallel
#---------------------------------------------
list_of_original_samples <- vector(mode = "list")
cores <- detectCores()
cl <- makeCluster(cores[1]-1)
registerDoParallel(cl)
list_of_samples <- foreach(1:nsam) %dopar%{
list_of_original_samples[["A"]] = DT_A[sample(nrow(DT_A),na),]
list_of_original_samples[["B"]] = DT_B[sample(nrow(DT_B),nb),]
list_of_original_samples[["C"]] = DT_C[sample(nrow(DT_C),nc),]
return(list_of_original_samples)
}
stopCluster(cl = cl)
#-----------------------------------------------
# Generation nboot bootstrap samples in parallel
#-----------------------------------------------
boot_function_1 <- function(list_of_original_samples){
boot_sample_tmp_A = list_of_original_samples[["A"]][sample(nrow(list_of_original_samples[["A"]]), na, replace = TRUE),]
boot_sample_tmp_B = list_of_original_samples[["B"]][sample(nrow(list_of_original_samples[["B"]]), nb, replace = TRUE),]
boot_sample_tmp_C = list_of_original_samples[["C"]][sample(nrow(list_of_original_samples[["C"]]), nc, replace = TRUE),]
PPV_A_e_tmp = (sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$Y==1 & boot_sample_tmp_A$E==1)) /
(sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$E==1))
PPV_B_e_tmp = (sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$Y==1 & boot_sample_tmp_B$E==1)) /
(sum(boot_sample_tmp_B$B==1 &  boot_sample_tmp_B$E==1))
PPV_C_e_tmp = (sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$Y==1 & boot_sample_tmp_C$E==0)) /
(sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$E==0))
PPV_A_ne_tmp = (sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$Y==1 & boot_sample_tmp_A$E==0)) /
(sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$E==0))
PPV_B_ne_tmp = (sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$Y==1 & boot_sample_tmp_B$E==0)) /
(sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$E==0))
PPV_C_ne_tmp = (sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$Y==1 & boot_sample_tmp_C$E==0)) /
(sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$E==0))
TX_boot0 = statistic_with_C_sample(P_A_e = P_A_e,
P_B_e = P_B_e,
P_C_e = P_C_e,
P_A_ne = P_A_ne,
P_B_ne = P_B_ne,
P_C_ne = P_C_ne,
PPV_A_e =  PPV_A_e_tmp,
PPV_B_e =  PPV_B_e_tmp,
PPV_C_e =  PPV_C_e_tmp,
PPV_A_ne = PPV_A_ne_tmp,
PPV_B_ne =  PPV_B_ne_tmp,
PPV_C_ne =  PPV_C_ne_tmp)
return(TX_boot0)
}
#tmp<-boot_function_1(list_of_samples[[1]])
boot_function_0 <- function(original_sample_data){
statistic_vector<- replicate(nboot, boot_function_1(original_sample_data))
quant_025 = quantile(statistic_vector,0.025, na.rm = T)
quant_975 = quantile(statistic_vector,0.975, na.rm = T)
return(as.integer(quant_025 < 0 & quant_975>0))
}
boot_function_2 <- function(list_of_original_samples){
TX_boot0 = c()
for (v in 1:nboot) {
boot_sample_tmp_A = list_of_original_samples[["A"]][sample(nrow(list_of_original_samples[["A"]]), na, replace = TRUE),]
boot_sample_tmp_B = list_of_original_samples[["B"]][sample(nrow(list_of_original_samples[["B"]]), nb, replace = TRUE),]
boot_sample_tmp_C = list_of_original_samples[["C"]][sample(nrow(list_of_original_samples[["C"]]), nc, replace = TRUE),]
PPV_A_e_tmp = (sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$Y==1 & boot_sample_tmp_A$E==1)) /
(sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$E==1))
PPV_B_e_tmp = (sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$Y==1 & boot_sample_tmp_B$E==1)) /
(sum(boot_sample_tmp_B$B==1 &  boot_sample_tmp_B$E==1))
PPV_C_e_tmp = (sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$Y==1 & boot_sample_tmp_C$E==0)) /
(sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$E==0))
PPV_A_ne_tmp = (sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$Y==1 & boot_sample_tmp_A$E==0)) /
(sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$E==0))
PPV_B_ne_tmp = (sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$Y==1 & boot_sample_tmp_B$E==0)) /
(sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$E==0))
PPV_C_ne_tmp = (sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$Y==1 & boot_sample_tmp_C$E==0)) /
(sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$E==0))
TX_boot0[v] = statistic_with_C_sample(P_A_e = P_A_e,
P_B_e = P_B_e,
P_C_e = P_C_e,
P_A_ne = P_A_ne,
P_B_ne = P_B_ne,
P_C_ne = P_C_ne,
PPV_A_e =  PPV_A_e_tmp,
PPV_B_e =  PPV_B_e_tmp,
PPV_C_e =  PPV_C_e_tmp,
PPV_A_ne = PPV_A_ne_tmp,
PPV_B_ne =  PPV_B_ne_tmp,
PPV_C_ne =  PPV_C_ne_tmp)
}
quant_025 = quantile(statistic_vector,0.025, na.rm = T)
quant_975 = quantile(statistic_vector,0.975, na.rm = T)
return(as.integer(quant_025 < 0 & quant_975>0))
}
#tmp<-boot_function_0(nboot, list_of_samples[[1]])
# cores <- detectCores()
# cl <- makeCluster(cores[1]- 1)
# clusterExport(cl = cl, list("boot_function_0",
#                             "boot_function_1",
#                             "nboot",
#                             "list_of_samples",
#                             "na",
#                             "nb",
#                             "nc",
#                             "P_A_e" ,
#                             "P_B_e" ,
#                             "P_C_e" ,
#                             "P_A_ne",
#                             "P_B_ne",
#                             "P_C_ne",
#                             "statistic_with_C_sample"),
#               envir = environment())
# par_test <- function(n){
#   parSapply(cl = cl, seq(n), function(i){boot_function_0(nboot, list_of_samples[[1]])})
#par_test(1000)
# }
#results <- parLapply(cl = cl, list_of_samples, boot_function_0)
#results <- parLapply(cl = cl, list_of_samples, boot_function_0)
stopCluster(cl)
#####################
# for loop
start_parallel <- Sys.time()
cores <- detectCores()
cl <- makeCluster(cores[1]- 1)
clusterExport(cl = cl, list("boot_function_0",
"boot_function_1",
"nboot",
"list_of_samples",
"na",
"nb",
"nc",
"P_A_e" ,
"P_B_e" ,
"P_C_e" ,
"P_A_ne",
"P_B_ne",
"P_C_ne",
"statistic_with_C_sample"),
envir = environment())
# par_test <- function(n){
#   parSapply(cl = cl, seq(n), function(i){boot_function_0(nboot, list_of_samples[[1]])})
#par_test(1000)
# }
#results <- parLapply(cl = cl, list_of_samples, boot_function_0)
results <- parLapply(cl = cl, list_of_samples, boot_function_2)
stopCluster(cl)
end_parallel <- Sys.time()
time_parallel <- end_parallel - start_parallel
time_parallel
#----------------
# Bootstrap power
#----------------
# Sets: A==1 and B==1
P_A_e = data[A==1&E==1, .N]/data[E==1, .N]
P_A_ne = data[A==1&E==0, .N]/data[E==0, .N]
P_B_e = data[B==1&E==1, .N]/data[E==1, .N]
P_B_ne = data[B==1&E==0, .N]/data[E==0, .N]
P_C_e = data[C==1&E==1, .N]/data[E==1, .N]
P_C_ne = data[C==1&E==0, .N]/data[E==0, .N]
P_A =  data[A==1, .N]/N
P_B = data[B==1, .N]/N
P_C = data[C==1, .N]/N
DT_A <- data[A==1]
DT_B <- data[B==1]
DT_C <- data[C==1]
#---------------------------------------------
# Generation nsam original samples in parallel
#---------------------------------------------
list_of_original_samples <- vector(mode = "list")
cores <- detectCores()
cl <- makeCluster(cores[1]-1)
registerDoParallel(cl)
list_of_samples <- foreach(1:nsam) %dopar%{
list_of_original_samples[["A"]] = DT_A[sample(nrow(DT_A),na),]
list_of_original_samples[["B"]] = DT_B[sample(nrow(DT_B),nb),]
list_of_original_samples[["C"]] = DT_C[sample(nrow(DT_C),nc),]
return(list_of_original_samples)
}
stopCluster(cl = cl)
#-----------------------------------------------
# Generation nboot bootstrap samples in parallel
#-----------------------------------------------
boot_function_1 <- function(list_of_original_samples){
boot_sample_tmp_A = list_of_original_samples[["A"]][sample(nrow(list_of_original_samples[["A"]]), na, replace = TRUE),]
boot_sample_tmp_B = list_of_original_samples[["B"]][sample(nrow(list_of_original_samples[["B"]]), nb, replace = TRUE),]
boot_sample_tmp_C = list_of_original_samples[["C"]][sample(nrow(list_of_original_samples[["C"]]), nc, replace = TRUE),]
PPV_A_e_tmp = (sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$Y==1 & boot_sample_tmp_A$E==1)) /
(sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$E==1))
PPV_B_e_tmp = (sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$Y==1 & boot_sample_tmp_B$E==1)) /
(sum(boot_sample_tmp_B$B==1 &  boot_sample_tmp_B$E==1))
PPV_C_e_tmp = (sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$Y==1 & boot_sample_tmp_C$E==0)) /
(sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$E==0))
PPV_A_ne_tmp = (sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$Y==1 & boot_sample_tmp_A$E==0)) /
(sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$E==0))
PPV_B_ne_tmp = (sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$Y==1 & boot_sample_tmp_B$E==0)) /
(sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$E==0))
PPV_C_ne_tmp = (sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$Y==1 & boot_sample_tmp_C$E==0)) /
(sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$E==0))
TX_boot0 = statistic_with_C_sample(P_A_e = P_A_e,
P_B_e = P_B_e,
P_C_e = P_C_e,
P_A_ne = P_A_ne,
P_B_ne = P_B_ne,
P_C_ne = P_C_ne,
PPV_A_e =  PPV_A_e_tmp,
PPV_B_e =  PPV_B_e_tmp,
PPV_C_e =  PPV_C_e_tmp,
PPV_A_ne = PPV_A_ne_tmp,
PPV_B_ne =  PPV_B_ne_tmp,
PPV_C_ne =  PPV_C_ne_tmp)
return(TX_boot0)
}
#tmp<-boot_function_1(list_of_samples[[1]])
boot_function_0 <- function(original_sample_data){
statistic_vector<- replicate(nboot, boot_function_1(original_sample_data))
quant_025 = quantile(statistic_vector,0.025, na.rm = T)
quant_975 = quantile(statistic_vector,0.975, na.rm = T)
return(as.integer(quant_025 < 0 & quant_975>0))
}
boot_function_2 <- function(list_of_original_samples){
TX_boot0 = c()
for (v in 1:nboot) {
boot_sample_tmp_A = list_of_original_samples[["A"]][sample(nrow(list_of_original_samples[["A"]]), na, replace = TRUE),]
boot_sample_tmp_B = list_of_original_samples[["B"]][sample(nrow(list_of_original_samples[["B"]]), nb, replace = TRUE),]
boot_sample_tmp_C = list_of_original_samples[["C"]][sample(nrow(list_of_original_samples[["C"]]), nc, replace = TRUE),]
PPV_A_e_tmp = (sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$Y==1 & boot_sample_tmp_A$E==1)) /
(sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$E==1))
PPV_B_e_tmp = (sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$Y==1 & boot_sample_tmp_B$E==1)) /
(sum(boot_sample_tmp_B$B==1 &  boot_sample_tmp_B$E==1))
PPV_C_e_tmp = (sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$Y==1 & boot_sample_tmp_C$E==0)) /
(sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$E==0))
PPV_A_ne_tmp = (sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$Y==1 & boot_sample_tmp_A$E==0)) /
(sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$E==0))
PPV_B_ne_tmp = (sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$Y==1 & boot_sample_tmp_B$E==0)) /
(sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$E==0))
PPV_C_ne_tmp = (sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$Y==1 & boot_sample_tmp_C$E==0)) /
(sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$E==0))
TX_boot0[v] = statistic_with_C_sample(P_A_e = P_A_e,
P_B_e = P_B_e,
P_C_e = P_C_e,
P_A_ne = P_A_ne,
P_B_ne = P_B_ne,
P_C_ne = P_C_ne,
PPV_A_e =  PPV_A_e_tmp,
PPV_B_e =  PPV_B_e_tmp,
PPV_C_e =  PPV_C_e_tmp,
PPV_A_ne = PPV_A_ne_tmp,
PPV_B_ne =  PPV_B_ne_tmp,
PPV_C_ne =  PPV_C_ne_tmp)
}
quant_025 = quantile(TX_boot0,0.025, na.rm = T)
quant_975 = quantile(TX_boot0,0.975, na.rm = T)
return(as.integer(quant_025 < 0 & quant_975>0))
}
#tmp<-boot_function_0(nboot, list_of_samples[[1]])
# cores <- detectCores()
# cl <- makeCluster(cores[1]- 1)
# clusterExport(cl = cl, list("boot_function_0",
#                             "boot_function_1",
#                             "nboot",
#                             "list_of_samples",
#                             "na",
#                             "nb",
#                             "nc",
#                             "P_A_e" ,
#                             "P_B_e" ,
#                             "P_C_e" ,
#                             "P_A_ne",
#                             "P_B_ne",
#                             "P_C_ne",
#                             "statistic_with_C_sample"),
#               envir = environment())
# par_test <- function(n){
#   parSapply(cl = cl, seq(n), function(i){boot_function_0(nboot, list_of_samples[[1]])})
#par_test(1000)
# }
#results <- parLapply(cl = cl, list_of_samples, boot_function_0)
#results <- parLapply(cl = cl, list_of_samples, boot_function_0)
stopCluster(cl)
#####################
# for loop
start_parallel <- Sys.time()
cores <- detectCores()
cl <- makeCluster(cores[1]- 1)
clusterExport(cl = cl, list("boot_function_0",
"boot_function_1",
"nboot",
"list_of_samples",
"na",
"nb",
"nc",
"P_A_e" ,
"P_B_e" ,
"P_C_e" ,
"P_A_ne",
"P_B_ne",
"P_C_ne",
"statistic_with_C_sample"),
envir = environment())
# par_test <- function(n){
#   parSapply(cl = cl, seq(n), function(i){boot_function_0(nboot, list_of_samples[[1]])})
#par_test(1000)
# }
#results <- parLapply(cl = cl, list_of_samples, boot_function_0)
results <- parLapply(cl = cl, list_of_samples, boot_function_2)
stopCluster(cl)
end_parallel <- Sys.time()
time_parallel <- end_parallel - start_parallel
time_parallel
results
#-------------------
# Prevalences & Data
#-------------------
P_A_e = data[A==1&E==1, .N]/data[E==1, .N]
P_A_ne = data[A==1&E==0, .N]/data[E==0, .N]
P_B_e = data[B==1&E==1, .N]/data[E==1, .N]
P_B_ne = data[B==1&E==0, .N]/data[E==0, .N]
P_C_e = data[C==1&E==1, .N]/data[E==1, .N]
P_C_ne = data[C==1&E==0, .N]/data[E==0, .N]
P_A =  data[A==1, .N]/N
P_B = data[B==1, .N]/N
P_C = data[C==1, .N]/N
DT_A <- data[A==1]
DT_B <- data[B==1]
DT_C <- data[C==1]
#---------------------------------
# Generation nsam original samples
#---------------------------------
list_of_original_samples <- vector(mode = "list")
cores <- detectCores()
cl <- makeCluster(cores[1]-1)
registerDoParallel(cl)
list_of_samples <- foreach(1:nsam) %dopar%{
list_of_original_samples[["A"]] = DT_A[sample(nrow(DT_A),na),]
list_of_original_samples[["B"]] = DT_B[sample(nrow(DT_B),nb),]
list_of_original_samples[["C"]] = DT_C[sample(nrow(DT_C),nc),]
return(list_of_original_samples)
}
stopCluster(cl = cl)
#-------------------------------------------------------------------------------------
# Function to generate nboot bootstrap samples, cumputing the statistic and return 1/0
#-------------------------------------------------------------------------------------
boot_function <- function(list_of_original_samples){
TX_boot0 = c()
for (v in 1:nboot) {
boot_sample_tmp_A = list_of_original_samples[["A"]][sample(nrow(list_of_original_samples[["A"]]), na, replace = TRUE),]
boot_sample_tmp_B = list_of_original_samples[["B"]][sample(nrow(list_of_original_samples[["B"]]), nb, replace = TRUE),]
boot_sample_tmp_C = list_of_original_samples[["C"]][sample(nrow(list_of_original_samples[["C"]]), nc, replace = TRUE),]
PPV_A_e_tmp = (sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$Y==1 & boot_sample_tmp_A$E==1)) /
(sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$E==1))
PPV_B_e_tmp = (sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$Y==1 & boot_sample_tmp_B$E==1)) /
(sum(boot_sample_tmp_B$B==1 &  boot_sample_tmp_B$E==1))
PPV_C_e_tmp = (sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$Y==1 & boot_sample_tmp_C$E==0)) /
(sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$E==0))
PPV_A_ne_tmp = (sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$Y==1 & boot_sample_tmp_A$E==0)) /
(sum(boot_sample_tmp_A$A==1 & boot_sample_tmp_A$E==0))
PPV_B_ne_tmp = (sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$Y==1 & boot_sample_tmp_B$E==0)) /
(sum(boot_sample_tmp_B$B==1 & boot_sample_tmp_B$E==0))
PPV_C_ne_tmp = (sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$Y==1 & boot_sample_tmp_C$E==0)) /
(sum(boot_sample_tmp_C$C==1 & boot_sample_tmp_C$E==0))
TX_boot0[v] = statistic_with_C_sample(P_A_e = P_A_e,
P_B_e = P_B_e,
P_C_e = P_C_e,
P_A_ne = P_A_ne,
P_B_ne = P_B_ne,
P_C_ne = P_C_ne,
PPV_A_e =  PPV_A_e_tmp,
PPV_B_e =  PPV_B_e_tmp,
PPV_C_e =  PPV_C_e_tmp,
PPV_A_ne = PPV_A_ne_tmp,
PPV_B_ne =  PPV_B_ne_tmp,
PPV_C_ne =  PPV_C_ne_tmp)
}
quant_025 = quantile(TX_boot0,0.025, na.rm = T)
quant_975 = quantile(TX_boot0,0.975, na.rm = T)
return(as.integer(quant_025 < 0 & quant_975>0))
}
#-----------------------------------------------------------------------------
# Appling boot_function to list_of_samples and computing the power of the test
#-----------------------------------------------------------------------------
cores <- detectCores()
cl <- makeCluster(cores[1]- 1)
clusterExport(cl = cl, list("boot_function_0",
"boot_function_1",
"nboot",
"list_of_samples",
"na",
"nb",
"nc",
"P_A_e" ,
"P_B_e" ,
"P_C_e" ,
"P_A_ne",
"P_B_ne",
"P_C_ne",
"statistic_with_C_sample"),
envir = environment())
list_of_test_results <- parLapply(cl = cl, list_of_samples, boot_function_2)
stopCluster(cl)
list_of_test_results
sum(list_of_test_results)
Reduce("+", list_of_test_results)
nsam
power_of_test <- Reduce("+", list_of_test_results) / nsam
power_of_test
power_of_test <- 1 - (Reduce("+", list_of_test_results) / nsam)
power_of_test
rm(list=ls(all.names=TRUE))
### Setting the working directory
if (!require("rstudioapi")) install.packages("rstudioapi")
thisdir<-setwd(dirname(rstudioapi::getSourceEditorContext()$path))
thisdir<-setwd(dirname(rstudioapi::getSourceEditorContext()$path))
setwd(thisdir)
### Loading program parameters
source(paste0(thisdir,"/01_Parameters/ProgramParameters.R"))
### Setting study parameters
source(paste0(thisdir,"/01_Parameters/TestParameters_scenario2.R"))
### Loading test functions
source(paste0(thisdir,"/02_TestFunctions/TestStatistic.R"))
source(paste0(thisdir,"/02_TestFunctions/RiskRatio_estimator.R"))
### Generating data
source(paste0(thisdir,"/03_DataGen/ConditionalProbability.R"))
##############################################
### Non Differentiality test: non-Parallel ###
##############################################
start_non_parallel <- Sys.time()
### Test Power
source(paste0(thisdir,"/04_TestApplication/TestPower_with_C_sample.R"))
end_non_parallel <- Sys.time()
time_non_parallel <- end_non_parallel - start_non_parallel # Time difference of 7.164448 mins
##########################################
### Non Differentiality test: Parallel ###
##########################################
start_parallel <- Sys.time()
### Test Power
source(paste0(thisdir,"/04_TestApplication/TestPower_with_C_sample_parallel_parlapply.R"))
end_parallel <- Sys.time()
time_parallel <- end_parallel - start_parallel
time_non_parallel
start_parallel <- Sys.time()
### Test Power
source(paste0(thisdir,"/04_TestApplication/TestPower_with_C_sample_parallel_parlapply.R"))
end_parallel <- Sys.time()
time_parallel <- end_parallel - start_parallel
time_parallel
start_parallel <- Sys.time()
### Test Power
source(paste0(thisdir,"/04_TestApplication/TestPower_with_C_sample_parallel_parlapply.R"))
end_parallel <- Sys.time()
time_parallel
time_parallel <- end_parallel - start_parallel
time_parallel
2.3/8
8/2.3
rm(list=ls(all.names=TRUE))
### Setting the working directory
if (!require("rstudioapi")) install.packages("rstudioapi")
thisdir<-setwd(dirname(rstudioapi::getSourceEditorContext()$path))
thisdir<-setwd(dirname(rstudioapi::getSourceEditorContext()$path))
setwd(thisdir)
### Loading program parameters
source(paste0(thisdir,"/01_Parameters/ProgramParameters.R"))
### Setting study parameters
source(paste0(thisdir,"/01_Parameters/TestParameters_scenario3_ND.R"))
### Loading test functions
source(paste0(thisdir,"/02_TestFunctions/TestStatistic.R"))
source(paste0(thisdir,"/02_TestFunctions/RiskRatio_estimator.R"))
### Generating data
source(paste0(thisdir,"/03_DataGen/ConditionalProbability.R"))
### RR distribution
source(paste0(thisdir,"/07_RR/RiskRatio_MC_distribution_with_C_sample.R"))
#multiple indicator
plt_RR
mean(RR_est)
sqrt(var(RR_est))
#single indicator
plt_RR_single_indicator
mean(RR_single_indicator)
sqrt(var(RR_single_indicator))
### Non Differentiality test
source(paste0(thisdir,"/04_TestApplication/BootTest_with_C_sample.R"))
plt_test
### Test Power
source(paste0(thisdir,"/04_TestApplication/TestPower_with_C_sample_parallel_parlapply.R"))
test_power
# 0.054
# 0.062
power_of_test
